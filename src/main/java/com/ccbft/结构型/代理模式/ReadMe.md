    代理模式给某一个对象提供一个代理对象，并由代理对象控制对源对象的引用
![img_1.png](img_1.png)

    [静态代理]
![img.png](img.png)
    
    静态代理在 Java 或大数据中有许多应用场景，以下是一些常见的示例：

    远程调用：静态代理可以用于实现远程调用。客户端和服务器之间的通信可以通过代理对象来处理，并将请求和响应进行序列化和反序列化。

    安全授权：静态代理可以用于实现安全授权。代理对象可以对请求进行验证和授权，从而确保只有经过授权的用户可以访问受保护的资源。

    性能优化：静态代理可以用于实现性能优化。代理对象可以缓存结果并提供快速响应，以避免重复计算或加载。

    日志记录：静态代理可以用于实现日志记录。代理对象可以拦截方法调用并记录输入、输出和执行时间等信息，以便于调试和性能分析。

    事务管理：静态代理可以用于实现事务管理。代理对象可以在方法调用前后开启和提交事务，并在发生异常时回滚事务。

    这些只是静态代理在 Java 或大数据中的一些应用场景，实际上静态代理可以通过不同的方式来解决各种问题。

    
    [动态代理] [目标代理对象必须实现接口！]
    1.代理对象,不需要实现接口

    2.代理对象的生成,是利用JDK的API,动态的在内存中构建代理对象(需要我们指定创建代理对象/目标对象实现的接口的类型)
    代理类不用再实现接口了。但是，要求被代理对象必须有接口

    动态代理实现：

    Java.lang.reflect.Proxy类可以直接生成一个代理对象
    
    Proxy.newProxyInstance(ClassLoader loader, Class<?>[] interfaces, InvocationHandler h)生成一个代理对象

    参数1:ClassLoader loader 代理对象的类加载器 一般使用被代理对象的类加载器

    参数2:Class<?>[] interfaces 代理对象的要实现的接口
    一般使用的被代理对象实现的接口参数3:InvocationHandler h (接口)执行处理类
    InvocationHandler中的invoke(Object proxy, Method method, Object[] args)方法：调用代理类的任何方法，此方法都会执行

    参数3.1:代理对象(慎用)参数3.2:当前执行的方法参数3.3:当前执行的方法运行时传递过来的参数
    
    作用和静态代理是一样的，但是更灵活，不需要和目标对象实现同一接口，什么类我都能代理。


    [CGLIB代理]
    CGLIB 原理：动态生成一个要代理类的子类，子类重写要代理的类的所有不是final的方法。
    在子类中采用方法拦截的技术拦截所有父类方法的调用，顺势织入横切逻辑。它比使用java反射的JDK动态代理要快。
    
    CGLIB 底层：使用字节码处理框架ASM，来转换字节码并生成新的类。
    不鼓励直接使用ASM，因为它要求你必须对JVM内部结构包括class文件的格式和指令集都很熟悉。
    
    CGLIB缺点：对于final方法，无法进行代理。
    
    用jdk动态代理还是cglib代理
    在一般情况下，如果你要代理的目标对象实现了接口且需要代理的方法比较少，那么使用JDK动态代理是一个不错的选择。
    相对而言，它比cglib更轻量级、速度更快，同时也更易于调试和排查问题。

    但是，如果你的目标对象没有实现接口，或者需要代理的方法比较多，那么就需要使用cglib代理了。
    
    总的来说，如果你想要一个通用型的、灵活性强的代理方案，可以考虑使用cglib代理。
    如果你只是需要代理一些简单的接口方法，或者对性能要求比较高，可以优先考虑JDK动态代理。






    装饰者模式（Decorator Pattern）和代理模式（Proxy Pattern）都属于结构型设计模式
    它们的目的是在不改变原有代码的情况下扩展或修改已有对象的行为。

    不同之处在于，装饰者模式旨在动态地将责任附加到对象上，而代理模式则是控制对对象的访问。具体来说：

    装饰者模式通过包装一个对象来[增强其功能]，同时保持[接口的一致性]。装饰者模式可以[嵌套使用]，以实现更复杂的功能。
    
    代理模式[控制对对象的访问]，通常是因为原始对象无法满足某些特定要求或安全限制。
    代理模式可以在客户端和原始对象之间添加一个中介层，从而实现更高级别的控制。

    总的来说，装饰者模式用于动态地添加或修改对象的功能，而代理模式用于控制对象的访问。
