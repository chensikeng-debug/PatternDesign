    代理模式给某一个对象提供一个代理对象，并由代理对象控制对源对象的引用
    
    [静态代理]
![img.png](img.png)
    
    静态代理在 Java 或大数据中有许多应用场景，以下是一些常见的示例：

    远程调用：静态代理可以用于实现远程调用。客户端和服务器之间的通信可以通过代理对象来处理，并将请求和响应进行序列化和反序列化。

    安全授权：静态代理可以用于实现安全授权。代理对象可以对请求进行验证和授权，从而确保只有经过授权的用户可以访问受保护的资源。

    性能优化：静态代理可以用于实现性能优化。代理对象可以缓存结果并提供快速响应，以避免重复计算或加载。

    日志记录：静态代理可以用于实现日志记录。代理对象可以拦截方法调用并记录输入、输出和执行时间等信息，以便于调试和性能分析。

    事务管理：静态代理可以用于实现事务管理。代理对象可以在方法调用前后开启和提交事务，并在发生异常时回滚事务。

    这些只是静态代理在 Java 或大数据中的一些应用场景，实际上静态代理可以通过不同的方式来解决各种问题。

    
    [动态代理]

    
    CGLIB代理







    装饰者模式（Decorator Pattern）和代理模式（Proxy Pattern）都属于结构型设计模式
    它们的目的是在不改变原有代码的情况下扩展或修改已有对象的行为。

    不同之处在于，装饰者模式旨在动态地将责任附加到对象上，而代理模式则是控制对对象的访问。具体来说：

    装饰者模式通过包装一个对象来[增强其功能]，同时保持[接口的一致性]。装饰者模式可以[嵌套使用]，以实现更复杂的功能。
    
    代理模式[控制对对象的访问]，通常是因为原始对象无法满足某些特定要求或安全限制。
    代理模式可以在客户端和原始对象之间添加一个中介层，从而实现更高级别的控制。

    总的来说，装饰者模式用于动态地添加或修改对象的功能，而代理模式用于控制对象的访问。
